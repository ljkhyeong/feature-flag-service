# 회고 - 2025-09-09

## 2025-09-08 ~ 2025-09-09 한 일
- **/sdk/v1/config 엔드포인트 초안 구현**
    - 컨트롤러에서 `GET /sdk/v1/config?env=stage` 제공
    - `If-None-Match` 지원 → 동일 ETag일 경우 `304 Not Modified` 반환
    - 응답에 `Cache-Control: no-cache`, `ETag` 헤더 적용
- **서비스 레이어 구현**
    - DB에서 env별 플래그 조회
    - DTO 변환 (FlagItem 리스트 + 번들 버전)
    - 번들 JSON 직렬화 후 SHA-256 해시 → ETag 생성
- **DTO/리포지토리 보강**
    - `SdkConfigResponse`, `FlagItem` DTO 추가
    - `FeatureFlagRepository.findAllByEnv()` 메서드 추가
- **REST Docs 테스트 작성**
    - 정상 조회(200) → 응답 JSON/ETag 문서화
    - ETag 일치 시 304 케이스 → 문서화
- **기존 REST Docs 테스트 실패 Fix**
    - FlagControllerTest의 `PUT /api/flags/{id} - 404 실패`가 500을 뱉음 
  → 요청 body가 비어있으면 HttpMessageNotReadableException이 발생하므로 ExceptionHandler에 추가  
- **gzip 압축 설정**
    - `application.yml`에 JSON 응답 gzip 압축 활성화
    - `Accept-Encoding: gzip` 요청 시 `Content-Encoding: gzip` 응답 확인 가능

## 배운 점
- **ETag 해시를 payload에서 직접 산출**하면 데이터 변경에 자동 반영되므로 깔끔하다.
- **If-None-Match**를 통해 304 응답을 반환하면 서버/클라이언트 모두 불필요한 전송을 줄일 수 있다.
- **RequestBody**가 null이면 역직렬화 실패로 HttpMessageNotReadableException이 발생하므로 핸들해줘야 한다.

## 아쉬운 점
- 무조건 서버에 검증해야하는 no-cache에서 더 나아가 유효기간 기반 캐시로 가능할까 공부 필요.
- payload 해시를 Etag로 하면 정확성은 좋지만 매번 해싱연산 비용이 들지 않을까? updatedAt 필드로 하는게 더 나을까? 공부 필요.
